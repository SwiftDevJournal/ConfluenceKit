// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Content {
    public var convertIDsToTypes: ConvertIDsToTypes {
        ConvertIDsToTypes(path: path + "/convert-ids-to-types")
    }

    public struct ConvertIDsToTypes {
        /// Path: `/content/convert-ids-to-types`
        public let path: String

        /// Convert content ids to content types
        ///
        /// Converts a list of content ids into their associated content types. This is useful for users migrating from v1 to v2
        /// who may have stored just content ids without their associated type. This will return types as they should be used in v2.
        /// Notably, this will return `inline-comment` for inline comments and `footer-comment` for footer comments, which is distinct from them
        /// both being represented by `comment` in v1.
        /// 
        /// **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// Permission to view the requested content. Any content that the user does not have permission to view or does not exist will map to `null` in the response.
        public func post(contentIDs: [PostRequest.ContentID]) -> Request<ConfluenceKit.ContentIDToContentTypeResponse> {
            Request(path: path, method: "POST", body: PostRequest(contentIDs: contentIDs), id: "convertContentIdsToContentTypes")
        }

        public struct PostRequest: Encodable {
            /// The content ids to convert. They may be provided as strings or numbers.
            public var contentIDs: [ContentID]

            public struct ContentID: Encodable {
                public var string: String?
                public var double: Double?

                public init(string: String? = nil, double: Double? = nil) {
                    self.string = string
                    self.double = double
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.singleValueContainer()
                    if let value = string { try container.encode(value) }
                    if let value = double { try container.encode(value) }
                }
            }

            public init(contentIDs: [ContentID]) {
                self.contentIDs = contentIDs
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(contentIDs, forKey: "contentIds")
            }
        }
    }
}
