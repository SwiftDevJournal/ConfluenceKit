// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CreateInlineCommentModel: Codable {
    /// ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply.
    public var blogPostID: String?
    /// ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply.
    public var pageID: String?
    /// ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment.
    public var parentCommentID: String?
    public var body: Body?
    /// Object describing the text to highlight on the page/blog post. Only applicable for top level inline comments (not replies) and required in that case.
    public var inlineCommentProperties: InlineCommentProperties?

    public enum Body: Codable {
        case commentBodyWrite(CommentBodyWrite)
        case commentNestedBodyWrite(CommentNestedBodyWrite)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(CommentBodyWrite.self) {
                self = .commentBodyWrite(value)
            } else if let value = try? container.decode(CommentNestedBodyWrite.self) {
                self = .commentNestedBodyWrite(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (CommentBodyWrite, CommentNestedBodyWrite)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .commentBodyWrite(let value): try container.encode(value)
            case .commentNestedBodyWrite(let value): try container.encode(value)
            }
        }
    }

    /// Object describing the text to highlight on the page/blog post. Only applicable for top level inline comments (not replies) and required in that case.
    public struct InlineCommentProperties: Codable {
        /// The text to highlight
        public var textSelection: String?
        /// The number of matches for the selected text on the page (should be strictly greater than textSelectionMatchIndex)
        public var textSelectionMatchCount: Int?
        /// The match index to highlight. This is zero-based. E.g. if you have 3 occurrences of "hello world" on a page 
        /// and you want to highlight the second occurrence, you should pass 1 for textSelectionMatchIndex and 3 for textSelectionMatchCount.
        public var textSelectionMatchIndex: Int?

        public init(textSelection: String? = nil, textSelectionMatchCount: Int? = nil, textSelectionMatchIndex: Int? = nil) {
            self.textSelection = textSelection
            self.textSelectionMatchCount = textSelectionMatchCount
            self.textSelectionMatchIndex = textSelectionMatchIndex
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.textSelection = try values.decodeIfPresent(String.self, forKey: "textSelection")
            self.textSelectionMatchCount = try values.decodeIfPresent(Int.self, forKey: "textSelectionMatchCount")
            self.textSelectionMatchIndex = try values.decodeIfPresent(Int.self, forKey: "textSelectionMatchIndex")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(textSelection, forKey: "textSelection")
            try values.encodeIfPresent(textSelectionMatchCount, forKey: "textSelectionMatchCount")
            try values.encodeIfPresent(textSelectionMatchIndex, forKey: "textSelectionMatchIndex")
        }
    }

    public init(blogPostID: String? = nil, pageID: String? = nil, parentCommentID: String? = nil, body: Body? = nil, inlineCommentProperties: InlineCommentProperties? = nil) {
        self.blogPostID = blogPostID
        self.pageID = pageID
        self.parentCommentID = parentCommentID
        self.body = body
        self.inlineCommentProperties = inlineCommentProperties
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.blogPostID = try values.decodeIfPresent(String.self, forKey: "blogPostId")
        self.pageID = try values.decodeIfPresent(String.self, forKey: "pageId")
        self.parentCommentID = try values.decodeIfPresent(String.self, forKey: "parentCommentId")
        self.body = try values.decodeIfPresent(Body.self, forKey: "body")
        self.inlineCommentProperties = try values.decodeIfPresent(InlineCommentProperties.self, forKey: "inlineCommentProperties")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(blogPostID, forKey: "blogPostId")
        try values.encodeIfPresent(pageID, forKey: "pageId")
        try values.encodeIfPresent(parentCommentID, forKey: "parentCommentId")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encodeIfPresent(inlineCommentProperties, forKey: "inlineCommentProperties")
    }
}
