// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct ContentIDToContentTypeResponse: Codable {
    /// JSON object containing all requested content ids as keys and their associated content types as the values.
    /// Duplicate content ids in the request will be returned under a single key in the response. For built-in content
    /// types, the enumerations are as specified. Custom content ids will be mapped to their associated type.
    public var results: [String: Result]?

    public struct Result: Codable {
        /// Built in content types
        public var object: Object?
        /// Custom content types
        public var string: String?

        /// Built in content types
        public enum Object: String, Codable, CaseIterable {
            case page
            case blogpost
            case attachment
            case footerComment = "footer-comment"
            case inlineComment = "inline-comment"
        }

        public init(object: Object? = nil, string: String? = nil) {
            self.object = object
            self.string = string
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.object = try? container.decode(Object.self)
            self.string = try? container.decode(String.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = object { try container.encode(value) }
            if let value = string { try container.encode(value) }
        }
    }

    public init(results: [String: Result]? = nil) {
        self.results = results
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.results = try values.decodeIfPresent([String: Result].self, forKey: "results")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(results, forKey: "results")
    }
}
